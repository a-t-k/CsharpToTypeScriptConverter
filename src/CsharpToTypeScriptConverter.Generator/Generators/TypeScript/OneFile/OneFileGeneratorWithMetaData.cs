using System;
using System.IO;
using System.Linq;
using System.Text;
using TypeScriptRequestCommandsGenerator.Models;
using TypeScriptRequestCommandsGenerator.Templates.SeparatedFiles.CodeGenerationWarning;
using TypeScriptRequestCommandsGenerator.Templates.SeparatedFiles.CommandInterface;
using TypeScriptRequestCommandsGenerator.Templates.SeparatedFiles.Commands;
using TypeScriptRequestCommandsGenerator.Templates.SeparatedFiles.ComplexTypes;
using TypeScriptRequestCommandsGenerator.Templates.SeparatedFiles.Enumerations;

namespace TypeScriptRequestCommandsGenerator.Generators.TypeScript.OneFile
{
    public class OneFileGeneratorWithMetaData(GeneratorType[] metadata)
    {
        public string TransformedText { get; set; }

        public OneFileGeneratorWithMetaData GenerateString()
        {
            var generated = new StringBuilder();

            // its text like "This file was generated by {ToolName} version {Version} on {GenerationTime}"
            string generatedWarning = new CodeGenerationWarning().TransformText();
            generated.Append(generatedWarning).Append(Environment.NewLine);

            // generate interface for commands
            string generatedTypeScriptCommandInterface = new CommandInterface().TransformText().Trim();
            generated.Append(generatedTypeScriptCommandInterface).Append(Environment.NewLine);

            // all enumerations
            string[] generatedEnumerations = metadata.Where(x => x.Kind == GeneratorTypeKind.Enum).Select(e =>
            {
                string enumGenerated = new EnumTypeScriptGenerator { TypeToGenerate = e }.TransformText().Trim();
                return enumGenerated;
            }).ToArray();
            foreach (string generatedEnumeration in generatedEnumerations)
            {
                generated.Append(generatedEnumeration).Append(Environment.NewLine);
            }

            // all commands
            string[] generatedCommands = metadata.Where(x => x.Kind == GeneratorTypeKind.CommandClass).Select(c =>
            {
                string commandGenerated = new CommandTypeScriptGenerator { TypeToGenerate = c }.TransformText().Trim();
                return commandGenerated;
            }).ToArray();
            foreach (string generatedCommand in generatedCommands)
            {
                generated.Append(generatedCommand).Append(Environment.NewLine);
            }

            string[] generatedTypes = metadata.Where(x => x.Kind == GeneratorTypeKind.Class).Select(c =>
            {
                string generatedType = new ComplexTypeScriptGenerator { TypeToGenerate = c }.TransformText().Trim();
                return generatedType;
            }).ToArray();
            foreach (string generatedType in generatedTypes)
            {
                generated.Append(generatedType).Append(Environment.NewLine);
            }

            this.TransformedText = generated.ToString();
            return this;
        }

        public OneFileGeneratorWithMetaData Save(DirectoryInfo directory, string fileName)
        {
            if (directory.Exists)
            {
                string path = Path.Combine(directory.FullName, fileName);
                File.AppendAllText(path, this.TransformedText, Encoding.UTF8);
            }

            return this;
        }
    }
}
