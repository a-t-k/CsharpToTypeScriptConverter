using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using TypeScriptRequestCommandsGenerator.Models;
using TypeScriptRequestCommandsGenerator.Templates.SeparatedFiles.CodeGenerationWarning;
using TypeScriptRequestCommandsGenerator.Templates.SeparatedFiles.CommandInterface;
using TypeScriptRequestCommandsGenerator.Templates.SeparatedFiles.Commands;
using TypeScriptRequestCommandsGenerator.Templates.SeparatedFiles.ComplexTypes;
using TypeScriptRequestCommandsGenerator.Templates.SeparatedFiles.Enumerations;
using TypeScriptRequestCommandsGenerator.Templates.SeparatedFiles.TypeScriptImports;
using TypeScriptRequestCommandsGenerator.Tools;

namespace TypeScriptRequestCommandsGenerator.Generators.TypeScript.SeparatedFiles
{
    public class SeparatedFilesGeneratorWithMetaData(GeneratorType[] metadata, TypeFileGenerator typeFileGenerator)
    {
        public SeparatedFilesGeneratorWithRenderedTypes Generate(List<Type> ignoredCustomerTypes = null)
        {
            // its text like "This file was generated by {ToolName} version {Version} on {GenerationTime}"
            string generatedWarning = new CodeGenerationWarning().TransformText();

            // generate interface for commands
            string generatedTypeScriptCommandInterface = new CommandInterface().TransformText().Trim();
            var commandInterfaceFileToSave = new FileMetadata
            {
                FileMetadataType = FileMetadataType.CommandInterface,
                TransformedText = generatedTypeScriptCommandInterface,
                FilePath = Path.Combine(""),
                FileName = this.GetFileName(CommandInterface.Settings.RequestCommandInterfaceName),
                Name = CommandInterface.Settings.RequestCommandInterfaceName,
                Type = null
            };

            // all enumerations
            var generatedEnumerations = metadata.Where(x => x.Kind == GeneratorTypeKind.Enum).Select(e =>
            {
                string enumGenerated = new EnumTypeScriptGenerator { TypeToGenerate = e }.TransformText().Trim();
                string enumName = e.Name;
                return new FileMetadata
                {
                    FileMetadataType = FileMetadataType.Enumeration,
                    TransformedText = generatedWarning + enumGenerated,
                    FilePath = Path.Combine(typeFileGenerator.NamespacePath(e.Type)),
                    FileName = this.GetFileName(enumName),
                    Type = e.Type,
                    Name = enumName
                };
            }).ToArray();

            // all commands
            var generatedCommands = metadata.Where(x => x.Kind == GeneratorTypeKind.CommandClass).Select(c =>
            {
                string commandGenerated = new CommandTypeScriptGenerator { TypeToGenerate = c }.TransformText().Trim();
                var dependencies = new TypeDependencyResolver(ignoredCustomerTypes).GetDependencies(c.Type, false);

                string name = typeFileGenerator.GetFileNameFromType(c.Type);
                var result = dependencies.Select(d => new TypeScriptImportDependency
                {
                    Name = typeFileGenerator.GetFileNameFromType(d.Type),
                    Path = typeFileGenerator.GenerateRelativePath(c.Type.Namespace)
                           + typeFileGenerator.NamespacePath(d.Type)
                           + "/"
                           + typeFileGenerator.GetFileNameFromType(d.Type)
                }).ToList();
                result.Add(new TypeScriptImportDependency
                {
                    Name = CommandInterface.Settings.RequestCommandInterfaceName,
                    Path = typeFileGenerator.GenerateRelativePath(c.Type.Namespace) +
                           CommandInterface.Settings.RequestCommandInterfaceName
                });

                string importsGenerated = new TypeScriptImports { Dependencies = result.ToList() }.TransformText();
                return new FileMetadata
                {
                    FileMetadataType = FileMetadataType.Command,
                    TransformedText = generatedWarning + importsGenerated + commandGenerated,
                    FilePath = Path.Combine(typeFileGenerator.NamespacePath(c.Type)),
                    FileName = this.GetFileName(name),
                    Type = c.Type,
                    Name = name
                };
            }).ToArray();

            var generatedUsedTypes = metadata
                .Where(x => x.Kind is GeneratorTypeKind.Class or GeneratorTypeKind.Interface).Select(c =>
                {
                    string generatedType = new ComplexTypeScriptGenerator { TypeToGenerate = c }.TransformText().Trim();
                    var dependencies = new TypeDependencyResolver(ignoredCustomerTypes).GetDependencies(c.Type, false);
                    var fileGenerator = new TypeFileGenerator();
                    string name = fileGenerator.GetFileNameFromType(c.Type);
                    var result = dependencies.Select(d => new TypeScriptImportDependency
                    {
                        Name = fileGenerator.GetFileNameFromType(d.Type),
                        Path = fileGenerator.GenerateRelativePath(c.Type.Namespace)
                               + fileGenerator.NamespacePath(d.Type)
                               + "/"
                               + fileGenerator.GetFileNameFromType(d.Type)
                    });

                    string importsGenerated = new TypeScriptImports { Dependencies = result.ToList() }.TransformText();
                    return new FileMetadata
                    {
                        FileMetadataType = FileMetadataType.UsedType,
                        Name = name,
                        TransformedText = generatedWarning + importsGenerated + generatedType,
                        FilePath = Path.Combine(fileGenerator.NamespacePath(c.Type)),
                        FileName = this.GetFileName(name),
                        Type = c.Type
                    };
                }).ToArray();

            var allGeneratedFiles = new List<FileMetadata> { commandInterfaceFileToSave };
            allGeneratedFiles.AddRange(generatedEnumerations);
            allGeneratedFiles.AddRange(generatedCommands);
            allGeneratedFiles.AddRange(generatedUsedTypes);
            return new SeparatedFilesGeneratorWithRenderedTypes(allGeneratedFiles);
        }

        private string GetFileName(string name) => $"{name}.ts";
    }
}
